import os
import re
import json
import time
import socket
import platform
import subprocess

try:
    import psutil  # type: ignore
except Exception:
    psutil = None

try:
    import requests  # type: ignore
except Exception:
    requests = None

# ----------------------------
# Config
# ----------------------------
# Ajuste para o IP/host do seu servidor caso o agente rode em outra mÃ¡quina.
POST_URL = os.environ.get("IRAMGW_AGENT_CHECK_URL", "http://104.234.30.69:4444/pc-check")
SEND_INTERVAL_SEC = 60


def _script_dir():
    return os.path.dirname(os.path.abspath(__file__))


def get_port():
    cfg_path = os.path.join(_script_dir(), "agent_check_port.txt")
    if os.path.exists(cfg_path):
        with open(cfg_path, "r", encoding="utf-8") as f:
            return f.read().strip()
    port = input("Digite a sua porta: ").strip()
    with open(cfg_path, "w", encoding="utf-8") as f:
        f.write(port)
    return port


def is_apipa(ip: str) -> bool:
    return ip.startswith("169.254.")


def get_default_gateway_ipv4():
    try:
        out = subprocess.check_output(["ipconfig"], text=True, encoding="cp850", errors="ignore")
        m = re.findall(r"(?:Gateway padrÃ£o|Default Gateway)[^\\d]*(\\d+\\.\\d+\\.\\d+\\.\\d+)", out)
        if m:
            for gw in m:
                if not is_apipa(gw):
                    return gw
    except Exception:
        pass
    return None


def is_private_candidate(ip: str) -> int:
    if ip.startswith("192.168."):
        return 300
    if ip.startswith("10."):
        return 200
    if ip.startswith("172."):
        try:
            a = int(ip.split(".")[1])
            if 16 <= a <= 31:
                return 150
        except Exception:
            pass
        return 50
    return 0


def get_local_ipv4():
    if psutil is None:
        return ""

    gw = get_default_gateway_ipv4()
    candidates = []
    for _, addrs in psutil.net_if_addrs().items():
        for a in addrs:
            if a.family == socket.AF_INET:
                ip = a.address
                if not ip or ip.startswith("127.") or is_apipa(ip):
                    continue
                candidates.append(ip)

    if not candidates:
        return ""

    if gw:
        gw_base = ".".join(gw.split(".")[:3]) + "."
        same = [ip for ip in candidates if ip.startswith(gw_base)]
        if same:
            same.sort(key=is_private_candidate, reverse=True)
            return same[0]

    candidates.sort(key=is_private_candidate, reverse=True)
    return candidates[0]


def format_uptime(seconds: int) -> str:
    if seconds < 0:
        seconds = 0
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    return f"{hours}h {minutes:02d}m"


def get_uptime_text():
    if psutil is None:
        return ""
    try:
        boot = int(psutil.boot_time())
        now = int(time.time())
        return format_uptime(now - boot)
    except Exception:
        return ""


def get_os_name():
    try:
        system = platform.system() or "Windows"
        release = platform.release() or ""
        if system.lower() == "windows":
            return f"Windows {release}".strip()
        return f"{system} {release}".strip()
    except Exception:
        return ""


def list_processes():
    """
    Retorna lista de processos para exibir no dashboard.
    Sem dependÃªncias extras: usa psutil se existir; senÃ£o tenta 'tasklist' no Windows.
    """
    procs = []

    if psutil is not None:
        try:
            for p in psutil.process_iter(["name", "memory_info"]):
                info = p.info or {}
                name = (info.get("name") or "").strip()
                if not name:
                    continue
                mem = info.get("memory_info")
                mem_mb = (mem.rss / (1024 * 1024)) if mem and getattr(mem, "rss", None) else None
                procs.append({"name": name, "cpu": None, "mem_mb": mem_mb})

            procs.sort(key=lambda x: (x["mem_mb"] or 0), reverse=True)
            # manda mais do que 5 (UI controla rolagem); limita para nÃ£o estourar payload
            return procs[:30]
        except Exception:
            pass

    # Fallback Windows
    try:
        out = subprocess.check_output(["tasklist"], text=True, encoding="cp850", errors="ignore")
        lines = [ln.strip() for ln in out.splitlines() if ln.strip()]
        for ln in lines[3:]:  # pula cabeÃ§alho
            parts = re.split(r"\\s{2,}", ln)
            if not parts:
                continue
            name = parts[0].strip()
            if name and not name.lower().startswith("nome da imagem"):
                procs.append({"name": name, "cpu": None, "mem_mb": None})
        return procs[:30]
    except Exception:
        return []


def post_payload(port: str, payload: dict):
    if requests is None:
        print("requests nÃ£o estÃ¡ instalado. Instale com: pip install requests")
        return False
    try:
        url = f"{POST_URL}?port={port}"
        r = requests.post(url, data=json.dumps(payload), headers={"Content-Type": "application/json"}, timeout=7)
        if r.status_code == 200:
            return True
        print(f"Falha HTTP {r.status_code}: {r.text[:200]}")
        return False
    except Exception as e:
        print(f"Erro enviando dados: {e}")
        return False


if __name__ == "__main__":
    port = get_port()
    print(f"Using port: {port}")

    hostname = socket.gethostname() or "DESKTOP"
    ip = get_local_ipv4()
    os_name = get_os_name()

    while True:
        uptime = get_uptime_text()
        processes = list_processes()

        payload = {
            "hostname": hostname,
            "status": "Online",
            "ip": ip,
            "os": os_name,
            "uptime": uptime,
            "processes": processes,
            "collected_at": int(time.time()),
        }

        ok = post_payload(port, payload)
        print("OK" if ok else "ERRO", "-", hostname, ip, uptime, f"procs={len(processes)}")
        time.sleep(SEND_INTERVAL_SEC)
