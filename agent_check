import os
import re
import json
import time
import socket
import platform
import subprocess
import sys
from typing import List, Dict, Any, Optional
from urllib.parse import urlparse

print("TEST VERSION FINAL")


def _script_dir() -> str:
    # 1) PyInstaller (rodando como .exe)
    if getattr(sys, "frozen", False):
        return os.path.dirname(sys.executable)

    # 2) Rodando via exec() (pode não existir __file__)
    f = globals().get("__file__")
    if not f:
        return os.getcwd()

    # 3) Rodando como .py normal
    return os.path.dirname(os.path.abspath(f))


try:
    import psutil  # type: ignore
except Exception:
    psutil = None

try:
    import requests  # type: ignore
except Exception:
    requests = None


# ----------------------------
# Config
# ----------------------------
# Server principal (produção)
POST_URL = os.environ.get("IRAMGW_AGENT_CHECK_URL",
                          "http://104.234.30.69:4444/pc-check")

# Localhost (testes) - se estiver online, usa ele primeiro
LOCAL_POST_URL = os.environ.get(
    "IRAMGW_AGENT_LOCAL_URL", "http://127.0.0.1:4444/pc-check")

SEND_INTERVAL_SEC = int(os.environ.get("AGENT_SEND_INTERVAL_SEC", "15"))

# Quantos processos mandar no máximo (default alto). Ajuste se necessário.
MAX_PROCS = int(os.environ.get("AGENT_MAX_PROCS", "500"))

# Timeout curto para checar localhost (não pode travar o agente)
LOCAL_CHECK_TIMEOUT_SEC = float(os.environ.get(
    "AGENT_LOCAL_CHECK_TIMEOUT_SEC", "0.6"))

# Timeout do POST
POST_TIMEOUT_SEC = float(os.environ.get("AGENT_POST_TIMEOUT_SEC", "10"))

# Quando detecta intrusão, agente para de enviar dados até que o servidor libere
POLL_ACTION_INTERVAL_SEC = float(os.environ.get(
    "AGENT_POLL_ACTION_INTERVAL_SEC", "3"))
# When operator clicks 'ignore', suppress re-alerting for this duration (seconds)
IGNORE_DURATION_SEC = int(os.environ.get("AGENT_IGNORE_DURATION_SEC", "300"))

# Remediation retry settings: number of attempts per target and delay between attempts
REMEDIATION_RETRY_ATTEMPTS = int(os.environ.get(
    "AGENT_REMEDIATION_RETRY_ATTEMPTS", "3"))
REMEDIATION_RETRY_DELAY_SEC = float(
    os.environ.get("AGENT_REMEDIATION_RETRY_DELAY_SEC", "2"))

# URL do frontend/UI onde o arquivo command.html e as APIs estão disponíveis.
# Permite configurar onde o agente deve buscar o arquivo de comandos (ex: http://127.0.0.1:3000)
UI_URL = os.environ.get("IRAMGW_AGENT_UI_URL", "http://127.0.0.1:3000")

# Optional fixed token to authenticate agent requests to the server (16-digit recommended)
AGENT_TOKEN = os.environ.get("IRAMGW_AGENT_TOKEN", "").strip()

# caminhos possíveis para lista de processos suspeitos (será carregada se existir)
SUSPICIOUS_LIST_PATHS = [
    os.path.join(_script_dir(), "list.txt"),
    os.path.join(_script_dir(), "modulos", "Agent", "list.txt"),
    os.path.join(_script_dir(), "public", "modulos", "Agent", "list.txt"),
]

# Lista embutida padrão (fallback quando não houver arquivo externo)
SUSPICIOUS_PATTERNS_DEFAULT = [
    # GENÉRICOS
    "main", "main.exe",
    "service", "service.exe",
    "client", "client.exe",
    "server", "server.exe",
    "update", "update.exe",
    "updater", "updater.exe",
    "install", "install.exe",
    "setup", "setup.exe",
    "patch", "patch.exe",
    "loader", "loader.exe",
    "run", "run.exe",
    "task", "task.exe",
    "app", "app.exe",
    "agent", "agent.exe",
    "helper", "helper.exe",
    "worker", "worker.exe",
    "host", "host.exe",
    "runtime", "runtime.exe",
    # PARECE WINDOWS
    "svchosts", "svchosts.exe",
    "explore", "explore.exe",
    "winlogin", "winlogin.exe",
    "lsasss", "lsasss.exe",
    "csrsss", "csrsss.exe",
    "taskmngr", "taskmngr.exe",
    "spoolsvc", "spoolsvc.exe",
    "serviceshost", "serviceshost.exe",
    "chromeupdate", "chromeupdate.exe",
    # LOLBINS
    "pwsh", "pwsh.exe",
    "cscript", "cscript.exe",
    "mshta", "mshta.exe",
    "rundll32", "rundll32.exe",
    "regsvr32", "regsvr32.exe",
    "schtasks", "schtasks.exe",
    "wmic", "wmic.exe",
    "bitsadmin", "bitsadmin.exe",
    "certutil", "certutil.exe",
    "net", "net.exe",
    "netsh", "netsh.exe",
    "sc", "sc.exe",
    # CONTROLE REMOTO
    "anydesk", "anydesk.exe",
    "teamviewer", "teamviewer.exe",
    "screenconnect", "screenconnect.exe",
    "splashtop", "splashtop.exe",
    "vnc", "vnc.exe",
    "tightvnc", "tightvnc.exe",
    "ultravnc", "ultravnc.exe",
    # FERRAMENTAS OFENSIVAS
    "mimikatz", "mimikatz.exe",
    "psexec", "psexec.exe",
    "procdump", "procdump.exe",
    "beacon", "beacon.exe",
    "cobaltstrike", "cobaltstrike.exe",
    "meterpreter", "meterpreter.exe",
    "empire", "empire.exe",
    "bloodhound", "bloodhound.exe",
    "netcat", "netcat.exe",
    "nc", "nc.exe",
    # KEYLOGGER / SPYWARE
    "keylogger", "keylogger.exe",
    "hook", "hook.exe",
    "capture", "capture.exe",
    "screen", "screen.exe",
    "spy", "spy.exe",
    "stealer", "stealer.exe",
    "grabber", "grabber.exe",
    "logger", "logger.exe",
    "monitor", "monitor.exe",
    "record", "record.exe",
    # MINERADORES
    "xmrig", "xmrig.exe",
    "miner", "miner.exe",
    "minerd", "minerd.exe",
    "cryptonight", "cryptonight.exe",
    "cpuhelper", "cpuhelper.exe",
    "gpuworker", "gpuworker.exe",
]


def get_port() -> str:
    cfg_path = os.path.join(_script_dir(), "agent_check_port.txt")
    if os.path.exists(cfg_path):
        with open(cfg_path, "r", encoding="utf-8") as f:
            return f.read().strip()
    port = input("Digite a sua porta: ").strip()
    with open(cfg_path, "w", encoding="utf-8") as f:
        f.write(port)
    return port


def is_apipa(ip: str) -> bool:
    return ip.startswith("169.254.")


def get_default_gateway_ipv4() -> Optional[str]:
    try:
        out = subprocess.check_output(
            ["ipconfig"], text=True, encoding="cp850", errors="ignore")
        m = re.findall(
            r"(?:Gateway padrão|Default Gateway)[^\d]*(\d+\.\d+\.\d+\.\d+)", out)
        if m:
            for gw in m:
                if not is_apipa(gw):
                    return gw
    except Exception:
        pass
    return None


def is_private_candidate(ip: str) -> int:
    if ip.startswith("192.168."):
        return 300
    if ip.startswith("10."):
        return 200
    if ip.startswith("172."):
        try:
            a = int(ip.split(".")[1])
            if 16 <= a <= 31:
                return 150
        except Exception:
            pass
        return 50
    return 0


def get_local_ipv4() -> str:
    if psutil is None:
        return ""

    gw = get_default_gateway_ipv4()
    candidates: List[str] = []
    for _, addrs in psutil.net_if_addrs().items():
        for a in addrs:
            if a.family == socket.AF_INET:
                ip = a.address
                if not ip or ip.startswith("127.") or is_apipa(ip):
                    continue
                candidates.append(ip)

    if not candidates:
        return ""

    if gw:
        gw_base = ".".join(gw.split(".")[:3]) + "."
        same = [ip for ip in candidates if ip.startswith(gw_base)]
        if same:
            same.sort(key=is_private_candidate, reverse=True)
            return same[0]

    candidates.sort(key=is_private_candidate, reverse=True)
    return candidates[0]


def format_uptime(seconds: int) -> str:
    if seconds < 0:
        seconds = 0
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    return f"{hours}h {minutes:02d}m"


def get_uptime_text() -> str:
    if psutil is None:
        return ""
    try:
        boot = int(psutil.boot_time())
        now = int(time.time())
        return format_uptime(now - boot)
    except Exception:
        return ""


def now_ts() -> str:
    try:
        return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    except Exception:
        return str(int(time.time()))


def get_os_name() -> str:
    try:
        system = platform.system() or "Windows"
        release = platform.release() or ""
        if system.lower() == "windows":
            return f"Windows {release}".strip()
        return f"{system} {release}".strip()
    except Exception:
        return ""


def _base_name(name: str) -> str:
    n = (name or "").strip().lower()
    if n.endswith(".exe"):
        n = n[:-4]
    return n


def list_processes() -> List[Dict[str, Any]]:
    """
    Retorna lista extensa de processos.
    Prioriza psutil (melhor qualidade). Fallback Windows tenta tasklist.
    """
    procs: List[Dict[str, Any]] = []

    # ----------------------------
    # Caminho ideal (psutil)
    # ----------------------------
    if psutil is not None:
        try:
            attrs = ["pid", "ppid", "name", "exe", "cmdline",
                     "username", "create_time", "memory_info"]
            for p in psutil.process_iter(attrs=attrs):
                info = p.info or {}
                name = (info.get("name") or "").strip()
                if not name:
                    continue

                mem = info.get("memory_info")
                mem_mb = None
                try:
                    if mem and getattr(mem, "rss", None) is not None:
                        mem_mb = float(mem.rss) / (1024 * 1024)
                except Exception:
                    mem_mb = None

                exe = info.get("exe")
                cmdline = info.get("cmdline")
                if isinstance(cmdline, tuple):
                    cmdline = list(cmdline)

                procs.append({
                    "pid": info.get("pid"),
                    "ppid": info.get("ppid"),
                    "name": name,
                    "base_name": _base_name(name),
                    "exe": exe if exe else None,
                    "cmdline": cmdline if cmdline else None,
                    "username": info.get("username") if info.get("username") else None,
                    "mem_mb": mem_mb,
                    "create_time": info.get("create_time") if info.get("create_time") else None,
                })

            # Ordena por memória só pra priorizar; você já vai detectar no front
            procs.sort(key=lambda x: (x.get("mem_mb") or 0), reverse=True)

            if MAX_PROCS > 0 and len(procs) > MAX_PROCS:
                procs = procs[:MAX_PROCS]

            return procs
        except Exception:
            pass

    # ----------------------------
    # Fallback Windows (tasklist)
    # ----------------------------
    try:
        out = subprocess.check_output(
            ["tasklist", "/FO", "CSV", "/NH"], text=True, encoding="cp850", errors="ignore")
        lines = [ln.strip() for ln in out.splitlines() if ln.strip()]
        for ln in lines:
            parts = [p.strip().strip('"') for p in ln.split('","')]
            if len(parts) < 2:
                continue
            name = parts[0].strip()
            pid = None
            try:
                pid = int(parts[1].strip())
            except Exception:
                pid = None

            mem_mb = None
            if len(parts) >= 5:
                mem_str = parts[4].replace(".", "").replace(
                    "K", "").replace("k", "").strip()
                try:
                    mem_kb = int(mem_str)
                    mem_mb = mem_kb / 1024.0
                except Exception:
                    mem_mb = None

            if not name:
                continue

            procs.append({
                "pid": pid,
                "ppid": None,
                "name": name,
                "base_name": _base_name(name),
                "exe": None,
                "cmdline": None,
                "username": None,
                "mem_mb": mem_mb,
                "create_time": None,
            })

        if MAX_PROCS > 0 and len(procs) > MAX_PROCS:
            procs = procs[:MAX_PROCS]
        return procs
    except Exception:
        return []


def _is_url_reachable_http(url: str, timeout_sec: float) -> bool:
    """
    Verifica rápido se a URL está respondendo.
    Usa HEAD com fallback para GET (alguns servidores bloqueiam HEAD).
    """
    if requests is None:
        return False

    try:
        # Se a URL não tiver caminho, evita erro (mas aqui sempre tem /pc-check)
        r = requests.head(url, timeout=timeout_sec, allow_redirects=True)
        if 200 <= r.status_code < 500:
            return True
    except Exception:
        pass

    try:
        r = requests.get(url, timeout=timeout_sec, allow_redirects=True)
        if 200 <= r.status_code < 500:
            return True
    except Exception:
        pass

    return False


def choose_post_url() -> str:
    """
    Preferência:
    1) Se localhost estiver respondendo -> usa LOCAL_POST_URL
    2) Caso contrário -> usa POST_URL (servidor)
    """
    # Try LOCAL_POST_URL first when it points to localhost, then UI_URL if local, otherwise fallback to POST_URL.
    try:
        # prefer explicit LOCAL_POST_URL when it's a localhost address
        parsed_local = urlparse(LOCAL_POST_URL)
        local_host = (parsed_local.hostname or "").lower()
        if local_host in ("localhost", "127.0.0.1"):
            try:
                if _is_url_reachable_http(LOCAL_POST_URL, LOCAL_CHECK_TIMEOUT_SEC):
                    print(
                        f"{now_ts()} choose_post_url: using LOCAL_POST_URL {LOCAL_POST_URL}")
                    return LOCAL_POST_URL
            except Exception:
                pass
    except Exception:
        pass

    # if UI_URL is explicitly local, prefer it next (useful when UI server hosts endpoints)
    try:
        parsed_ui = urlparse(UI_URL)
        ui_host = (parsed_ui.hostname or "").lower()
        if ui_host in ("localhost", "127.0.0.1"):
            try:
                if _is_url_reachable_http(UI_URL, LOCAL_CHECK_TIMEOUT_SEC):
                    print(f"{now_ts()} choose_post_url: using UI_URL {UI_URL}")
                    return UI_URL
            except Exception:
                pass
    except Exception:
        pass

    print(f"{now_ts()} choose_post_url: using remote POST_URL {POST_URL}")
    return POST_URL


def load_suspicious_patterns() -> List[str]:
    """Tenta carregar uma lista local de padrões (uma por linha)."""
    patterns: List[str] = []
    for p in SUSPICIOUS_LIST_PATHS:
        try:
            if os.path.exists(p):
                with open(p, "r", encoding="utf-8") as f:
                    for ln in f:
                        ln = ln.strip()
                        if not ln or ln.startswith("#"):
                            continue
                        patterns.append(ln.lower())
                if patterns:
                    return patterns
        except Exception:
            continue

    # fallback: tentar buscar no servidor público (mesmo host base que POST_URL)
    try:
        base = choose_post_url()
        # transforma http://host:port/pc-check -> http://host:port/modulos/Agent/list.txt
        parsed = urlparse(base)
        root = f"{parsed.scheme}://{parsed.hostname}:{parsed.port}"
        url = root + "/modulos/Agent/list.txt"
        if requests is not None:
            r = requests.get(url, timeout=2)
            if r.status_code == 200:
                for ln in r.text.splitlines():
                    ln = ln.strip()
                    if not ln or ln.startswith("#"):
                        continue
                    patterns.append(ln.lower())
    except Exception:
        pass

    if patterns:
        return patterns

    # fallback to embedded default patterns
    return list(SUSPICIOUS_PATTERNS_DEFAULT)


def _normalize_pattern(s: str) -> str:
    s = (s or "").strip().lower()
    if s.endswith('.exe'):
        return s
    return s


def find_suspicious_in_processes(processes: List[Dict[str, Any]], patterns: List[str]) -> List[str]:
    # simple list of matching process names (kept for compatibility)
    details = find_suspicious_details(processes, patterns)
    return [d['name'] for d in details]


def find_suspicious_details(processes: List[Dict[str, Any]], patterns: List[str]) -> List[Dict[str, Any]]:
    """Return list of { name: <proc name>, matches: [pattern, ...] }"""
    results: List[Dict[str, Any]] = []
    if not patterns:
        return results
    pats = set(_normalize_pattern(p) for p in patterns if p)
    for proc in processes:
        name = (proc.get('name') or '').strip()
        if not name:
            continue
        lname = name.lower()
        base = (proc.get('base_name') or lname.replace('.exe', '')).lower()

        # prepare cmdline / exe strings
        cmdline_val = proc.get('cmdline')
        cmdline_str = ''
        try:
            if isinstance(cmdline_val, (list, tuple)):
                cmdline_str = ' '.join(str(x) for x in cmdline_val if x)
            elif cmdline_val:
                cmdline_str = str(cmdline_val)
        except Exception:
            cmdline_str = ''
        cmdline_str = cmdline_str.lower()
        exe_str = (proc.get('exe') or '')
        exe_str = exe_str.lower() if isinstance(exe_str, str) else ''

        matched_patterns: List[str] = []
        for p in pats:
            if not p:
                continue
            try:
                # Normalize pattern and compare strictly to process base name or exe basename.
                if p.endswith('.exe'):
                    core = p[:-4]
                    exe_basename = os.path.basename(exe_str) if exe_str else ''
                    if base == core or exe_basename.lower() == p:
                        matched_patterns.append(p)
                else:
                    exe_basename = os.path.basename(exe_str) if exe_str else ''
                    if base == p or exe_basename.lower() == p:
                        matched_patterns.append(p)
            except Exception:
                continue

        if matched_patterns:
            results.append({
                'name': name,
                'pid': proc.get('pid'),
                'exe': proc.get('exe'),
                'matches': matched_patterns,
            })

    return results


def post_payload(port: str, payload: dict) -> bool:
    if requests is None:
        print("requests não está instalado. Instale com: pip install requests")
        return False

    chosen_url = choose_post_url()
    try:
        url = f"{chosen_url}?port={port}"
        r = requests.post(
            url,
            data=json.dumps(payload),
            headers={"Content-Type": "application/json"},
            timeout=POST_TIMEOUT_SEC
        )
        if r.status_code == 200:
            return True
        print(f"Falha HTTP {r.status_code}: {r.text[:200]}")
        return False
    except Exception as e:
        print(f"Erro enviando dados: {e}")
        return False


def poll_action_for_host(port: str, hostname: str) -> Optional[Dict[str, Any]]:
    """Consulta /pc-action e retorna dict { action, target } quando disponível, senão None."""
    try:
        chosen = choose_post_url()
        parsed = urlparse(chosen)
        root = f"{parsed.scheme}://{parsed.hostname}:{parsed.port}"
        action_url = f"{root}/pc-action?port={port}&hostname={hostname}"
        if requests:
            r = requests.get(action_url, timeout=POST_TIMEOUT_SEC)
            if r.status_code == 200:
                try:
                    j = r.json()
                    if isinstance(j, dict) and j.get('ok') and j.get('allow'):
                        return {'action': j.get('action'), 'target': j.get('target')}
                except Exception:
                    return None
    except Exception:
        return None
    return None


def _kill_pid(pid_val: int) -> bool:
    try:
        system = platform.system().lower()
        if psutil:
            try:
                p = psutil.Process(int(pid_val))
                p.kill()
                return True
            except Exception:
                return False
        else:
            if system == 'windows':
                try:
                    subprocess.call(
                        ['taskkill', '/PID', str(int(pid_val)), '/F'])
                    return True
                except Exception:
                    return False
            else:
                try:
                    subprocess.call(['kill', '-9', str(int(pid_val))])
                    return True
                except Exception:
                    return False
    except Exception:
        return False


def _kill_by_name(name_val: str) -> bool:
    try:
        n = (name_val or '').lower()
        if not n:
            return False
        if psutil:
            ok = False
            for p in psutil.process_iter(['name', 'exe']):
                try:
                    nm = (p.info.get('name') or '').lower()
                    exe = (p.info.get('exe') or '') or ''
                    if n in nm or n in exe.lower():
                        try:
                            p.kill()
                            ok = True
                        except Exception:
                            pass
                except Exception:
                    pass
            return ok
        else:
            system = platform.system().lower()
            if system == 'windows':
                try:
                    subprocess.call(['taskkill', '/IM', name_val, '/F'])
                    return True
                except Exception:
                    return False
            else:
                try:
                    subprocess.call(['pkill', '-f', name_val])
                    return True
                except Exception:
                    return False
    except Exception:
        return False


def _kill_by_exe(exe_path: str) -> bool:
    """Kill processes whose executable path matches exe_path exactly (best-effort)."""
    try:
        if not exe_path:
            return False
        if psutil:
            ok = False
            norm_target = os.path.normcase(str(exe_path))
            for p in psutil.process_iter(['pid', 'exe', 'name']):
                try:
                    pe = (p.info.get('exe') or '')
                    if not pe:
                        continue
                    if os.path.normcase(pe) == norm_target:
                        try:
                            p.kill()
                            ok = True
                        except Exception:
                            pass
                except Exception:
                    pass
            return ok
        return False
    except Exception:
        return False


def _remove_file(path_val: str) -> bool:
    try:
        if not path_val:
            return False
        if os.path.exists(path_val):
            try:
                os.remove(path_val)
                return True
            except Exception:
                # try schedule delete on reboot (Windows)
                try:
                    if platform.system().lower() == 'windows':
                        try:
                            import ctypes
                            MOVEFILE_DELAY_UNTIL_REBOOT = 0x4
                            p = ctypes.windll.kernel32.MoveFileExW(
                                str(path_val), None, MOVEFILE_DELAY_UNTIL_REBOOT)
                            return bool(p)
                        except Exception:
                            return False
                except Exception:
                    return False
        return False
    except Exception:
        return False


def perform_action(action: str, target: Optional[Any]) -> bool:
    """Perform system actions: 'restart' or 'shutdown'. Returns True if the command was issued."""
    try:
        system = platform.system().lower()
        act = (action or '').lower()
        print(f"{now_ts()} Performing action: {act} target={target}")
        if act == 'restart':
            if system == 'windows':
                try:
                    subprocess.call(['shutdown', '/r', '/t', '0'])
                    return True
                except Exception:
                    return False
            else:
                try:
                    subprocess.call(['shutdown', '-r', 'now'])
                    return True
                except Exception:
                    try:
                        subprocess.call(['reboot'])
                        return True
                    except Exception:
                        return False
        if act == 'shutdown':
            if system == 'windows':
                try:
                    subprocess.call(['shutdown', '/s', '/t', '0'])
                    return True
                except Exception:
                    return False
            else:
                try:
                    subprocess.call(['shutdown', '-h', 'now'])
                    return True
                except Exception:
                    try:
                        subprocess.call(['poweroff'])
                        return True
                    except Exception:
                        return False
        print(f"{now_ts()} Unknown action: {action}")
        return False
    except Exception:
        return False


# NOTE: command.html and remote command clearing are deprecated - operator commands via public/command.html removed.
def clear_command_entry(port: str) -> bool:
    return False


def report_activity(port: str, hostname: str, message: str, command: str, success: bool) -> bool:
    """Report a textual activity to the server (tries UI_URL then fallback)."""
    try:
        payload = {
            "port": str(port),
            "hostname": hostname,
            "message": message,
            "command": str(command),
            "success": bool(success)
        }
        # try UI first
        if requests:
            try:
                parsed_ui = urlparse(UI_URL)
                port_ui = parsed_ui.port or (
                    443 if parsed_ui.scheme == 'https' else 80)
                url_ui = f"{parsed_ui.scheme}://{parsed_ui.hostname}:{port_ui}/api/pcs/activity"
                headers = {}
                if AGENT_TOKEN:
                    headers['X-IRAMGW-TOKEN'] = AGENT_TOKEN
                r = requests.post(url_ui, json=payload, headers=headers,
                                  timeout=POST_TIMEOUT_SEC)
                if r.status_code == 200:
                    try:
                        return bool(r.json().get('ok'))
                    except Exception:
                        return True
            except Exception:
                pass

            try:
                chosen = choose_post_url()
                parsed = urlparse(chosen)
                url = f"{parsed.scheme}://{parsed.hostname}:{parsed.port}/api/pcs/activity"
                headers = {}
                if AGENT_TOKEN:
                    headers['X-IRAMGW-TOKEN'] = AGENT_TOKEN
                r = requests.post(url, json=payload,
                                  headers=headers, timeout=POST_TIMEOUT_SEC)
                if r.status_code == 200:
                    try:
                        return bool(r.json().get('ok'))
                    except Exception:
                        return True
            except Exception:
                pass
    except Exception:
        pass
    return False


if __name__ == "__main__":
    port = get_port()
    print(f"Using port: {port}")

    hostname = socket.gethostname() or "DESKTOP"
    ip = get_local_ipv4()
    os_name = get_os_name()

    # carregar padrões locais de processos suspeitos (se houver)
    suspicious_patterns = load_suspicious_patterns()
    if suspicious_patterns:
        print(f"Loaded {len(suspicious_patterns)} suspicious patterns")

    blocked = False
    # persist last detected intrusion processes/details so actions can use them
    last_intrusion_procs_full: List[Dict[str, Any]] = []
    suppressed_until = 0.0  # timestamp until which intrusion alerts are suppressed

    while True:
        uptime = get_uptime_text()
        processes = list_processes()

        # debug: announce comparison and list processes one-per-line
        print(
            f"{now_ts()} Comparando processos antes de enviar... (total: {len(processes)})")
        print(f"{now_ts()} Lista de processos detectados:")
        for p in processes:
            try:
                pname = p.get('name') or p.get('base_name') or ''
            except Exception:
                pname = str(p)
            print(f"{now_ts()} - {pname}")

        # detectar processos intrusos localmente se tivermos padrões
        intrusion_details = find_suspicious_details(
            processes, suspicious_patterns)
        intrusion_procs = [d['name'] for d in intrusion_details]
        # collect full process dicts for the detected intrusion processes
        if intrusion_procs:
            last_intrusion_procs_full = [p for p in processes if (
                p.get('name') or '').strip() in intrusion_procs]
        else:
            last_intrusion_procs_full = []
        # if we are currently suppressed (operator clicked ignore), skip alerting
        if suppressed_until and time.time() < suppressed_until:
            if intrusion_details:
                print(f"{now_ts()} Ignorado localmente até {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(suppressed_until))} - não envia ALERT")
            # clear intrusion lists so they don't trigger blocking
            intrusion_details = []
            intrusion_procs = []
        if intrusion_details:
            for d in intrusion_details:
                print(
                    f"{now_ts()} PERIGO --> Processo: {d['name']} encontrado... iniciando correção automática")
        if intrusion_procs and not blocked:
            # Send immediate alert and perform automatic remediation (command 1)
            alert_payload = {
                "hostname": hostname,
                "status": "ALERT",
                "ip": ip,
                "os": os_name,
                "uptime": uptime,
                "processes": processes,
                "process_count": len(processes),
                "collected_at": int(time.time()),
                "intrusion": True,
                "intrusion_processes": intrusion_procs,
                "blocked": False,
            }
            ok = post_payload(port, alert_payload)
            print(
                f"{now_ts()} {('ALERT SENT' if ok else 'ALERT ERRO')} - {hostname} {intrusion_procs}")

            # Build target list (exe path preferred, then name)
            chosen_targets: List[str] = []
            for lp in last_intrusion_procs_full:
                exe = lp.get('exe') or ''
                name = lp.get('name') or ''
                if exe:
                    chosen_targets.append(exe)
                elif name:
                    chosen_targets.append(name)

            # Attempt remediation for each target and report activity with retry
            results: List[bool] = []
            for t in chosen_targets:
                try:
                    overall_ok = False
                    attempt = 0
                    last_err = None
                    while attempt < REMEDIATION_RETRY_ATTEMPTS and not overall_ok:
                        attempt += 1
                        try:
                            ok_kill = False
                            ok_remove = False
                            if isinstance(t, int) or (isinstance(t, str) and t.isdigit()):
                                pid_val = int(t)
                                print(
                                    f"{now_ts()} [attempt {attempt}] Parando PID {pid_val}...")
                                ok_kill = _kill_pid(pid_val)
                            elif os.path.exists(str(t)):
                                print(
                                    f"{now_ts()} [attempt {attempt}] Parando processos que usam o exe {t}...")
                                ok_kill = _kill_by_exe(str(t))
                            else:
                                print(
                                    f"{now_ts()} [attempt {attempt}] Parando por nome: {t}...")
                                ok_kill = _kill_by_name(str(t))

                            if os.path.exists(str(t)):
                                print(
                                    f"{now_ts()} [attempt {attempt}] Tentando apagar arquivo {t}...")
                                ok_remove = _remove_file(str(t))
                                print(
                                    f"{now_ts()} [attempt {attempt}] Remoção {'ok' if ok_remove else 'falhou'}")
                            else:
                                print(
                                    f"{now_ts()} [attempt {attempt}] Arquivo {t} não existe, pular remoção")

                            overall_ok = bool(ok_kill or ok_remove)
                            if not overall_ok and attempt < REMEDIATION_RETRY_ATTEMPTS:
                                time.sleep(REMEDIATION_RETRY_DELAY_SEC)
                        except Exception as e:
                            last_err = e
                            overall_ok = False
                            if attempt < REMEDIATION_RETRY_ATTEMPTS:
                                time.sleep(REMEDIATION_RETRY_DELAY_SEC)

                    try:
                        msg = f"Arquivo/processo: {t} - {'corrigido' if overall_ok else 'falha ao corrigir'}"
                        print(f"{now_ts()} {msg} (auto:1) attempts={attempt}")
                        report_activity(port, hostname, msg, '1', overall_ok)
                    except Exception:
                        pass
                    results.append(bool(overall_ok))
                except Exception:
                    results.append(False)

            # send updated check to dashboard
            try:
                print(f"{now_ts()} Enviando check atualizado para a Dash...")
                time.sleep(1)
                updated_procs = list_processes()
                check_payload = {
                    "hostname": hostname,
                    "status": "Online",
                    "ip": ip,
                    "os": os_name,
                    "uptime": get_uptime_text(),
                    "processes": updated_procs,
                    "process_count": len(updated_procs),
                    "collected_at": int(time.time()),
                }
                posted = post_payload(port, check_payload)
                print(f"{now_ts()} Check atualizado enviado: {posted}")
                try:
                    report_activity(
                        port, hostname, "Check enviado apos correção", '1', bool(posted))
                except Exception:
                    pass
            except Exception:
                pass

            # decide whether to restart: only when all targets were corrected
            try:
                all_ok = (len(results) > 0 and all(results))
                if all_ok:
                    print(
                        f"{now_ts()} Todos os alvos corrigidos — reiniciando em 10s...")
                    time.sleep(10)
                    perform_action('restart', None)
                else:
                    print(
                        f"{now_ts()} Correção incompleta — NÃO será reiniciado. result list: {results}")
                    try:
                        report_activity(
                            port, hostname, f"Correção incompleta: {results}", '1', False)
                    except Exception:
                        pass
            except Exception:
                pass

            # continue main loop after remediation
            time.sleep(SEND_INTERVAL_SEC)
            continue

        if blocked:
            # não enviamos mais dados, apenas consultamos o servidor de ações
            try:
                # 1) first try the DB-backed /pc-action (existing mechanism)
                try:
                    pa = poll_action_for_host(port, hostname)
                    if pa and isinstance(pa, dict) and pa.get('action'):
                        action = pa.get('action')
                        target = pa.get('target')
                        print('Action allowed by server (pc-action):',
                              action, target)
                        if action and action.startswith('remove') and not target:
                            chosen_targets: List[str] = []
                            for lp in last_intrusion_procs_full:
                                exe = lp.get('exe') or ''
                                name = lp.get('name') or ''
                                if exe:
                                    chosen_targets.append(exe)
                                elif name:
                                    chosen_targets.append(name)
                            results: List[bool] = []
                            for t in chosen_targets:
                                try:
                                    ok = False
                                    try:
                                        if isinstance(t, int) or (isinstance(t, str) and t.isdigit()):
                                            ok = _kill_pid(int(t))
                                        elif os.path.exists(str(t)):
                                            ok = _remove_file(str(t))
                                        else:
                                            ok = _kill_by_name(str(t))
                                    except Exception:
                                        ok = False
                                    try:
                                        msg = f"Arquivo/processo: {t} - {'corrigido' if ok else 'falha ao corrigir'}"
                                        report_activity(
                                            port, hostname, msg, action, ok)
                                    except Exception:
                                        pass
                                    results.append(bool(ok))
                                except Exception:
                                    pass
                            # send an updated check to the dashboard before deciding to restart
                            try:
                                print(
                                    f"{now_ts()} Enviando check atualizado para a Dash...")
                                time.sleep(1)
                                updated_procs = list_processes()
                                check_payload = {
                                    "hostname": hostname,
                                    "status": "Online",
                                    "ip": ip,
                                    "os": os_name,
                                    "uptime": get_uptime_text(),
                                    "processes": updated_procs,
                                    "process_count": len(updated_procs),
                                    "collected_at": int(time.time()),
                                }
                                posted = post_payload(port, check_payload)
                                print(
                                    f"{now_ts()} Check atualizado enviado: {posted}")
                                try:
                                    report_activity(
                                        port, hostname, "Check enviado apos correção", action, bool(posted))
                                except Exception:
                                    pass
                            except Exception:
                                pass
                            # only restart if all targets were corrected
                            try:
                                all_ok = (len(results) > 0 and all(results))
                                if all_ok:
                                    print(
                                        f"{now_ts()} Todos os alvos corrigidos — reiniciando em 10s...")
                                    time.sleep(10)
                                    perform_action('restart', None)
                                else:
                                    print(
                                        f"{now_ts()} Correção incompleta — NÃO será reiniciado. result list: {results}")
                                    try:
                                        report_activity(
                                            port, hostname, f"Correção incompleta: {results}", action, False)
                                    except Exception:
                                        pass
                            except Exception:
                                pass
                        else:
                            if action == 'ignore':
                                try:
                                    suppressed_until = time.time() + float(IGNORE_DURATION_SEC)
                                    try:
                                        clear_command_entry(port)
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                except Exception:
                    pass

                # (command.html fallback removed)
            except Exception:
                pass
            time.sleep(POLL_ACTION_INTERVAL_SEC)
            continue

        # normal payload (quando não bloqueado)
        # Before sending normal payload, poll server for any pending action for this host
        pa = poll_action_for_host(port, hostname)
        if pa and isinstance(pa, dict) and pa.get('action'):
            try:
                action = pa.get('action')
                target = pa.get('target')
                print(f"{now_ts()} Action received pre-send: {action} {target}")
                # try to parse target JSON string
                if isinstance(target, str):
                    try:
                        target = json.loads(target)
                    except Exception:
                        pass
                if action:
                    if action and action.startswith('remove') and not target:
                        # fallback to last intrusion targets
                        chosen_targets: List[str] = []
                        for lp in last_intrusion_procs_full:
                            exe = lp.get('exe') or ''
                            name = lp.get('name') or ''
                            if exe:
                                chosen_targets.append(exe)
                            elif name:
                                chosen_targets.append(name)
                        for t in chosen_targets:
                            try:
                                ok = False
                                try:
                                    if isinstance(t, int) or (isinstance(t, str) and t.isdigit()):
                                        ok = _kill_pid(int(t))
                                    elif os.path.exists(str(t)):
                                        ok = _remove_file(str(t))
                                    else:
                                        ok = _kill_by_name(str(t))
                                except Exception:
                                    ok = False
                                try:
                                    msg = f"Arquivo/processo: {t} - {'corrigido' if ok else 'falha ao corrigir'}"
                                    report_activity(
                                        port, hostname, msg, action, ok)
                                except Exception:
                                    pass
                            except Exception:
                                pass
                        # send updated check before restart
                        try:
                            time.sleep(1)
                            updated_procs = list_processes()
                            check_payload = {
                                "hostname": hostname,
                                "status": "Online",
                                "ip": ip,
                                "os": os_name,
                                "uptime": get_uptime_text(),
                                "processes": updated_procs,
                                "process_count": len(updated_procs),
                                "collected_at": int(time.time()),
                            }
                            posted = post_payload(port, check_payload)
                            try:
                                report_activity(
                                    port, hostname, "Check enviado apos correção", action, bool(posted))
                            except Exception:
                                pass
                        except Exception:
                            pass
                        try:
                            perform_action('restart', None)
                        except Exception:
                            pass
                    else:
                        perform_action(action, target)
                # after performing action, skip sending telemetry this iteration
                time.sleep(POLL_ACTION_INTERVAL_SEC)
                continue
            except Exception:
                pass
        # (command.html usage removed) - no fallback polling of public/command.html

        payload = {
            "hostname": hostname,
            "status": "Online",
            "ip": ip,
            "os": os_name,
            "uptime": uptime,
            "processes": processes,
            "process_count": len(processes),
            "collected_at": int(time.time()),
        }

        ok = post_payload(port, payload)
        if ok:
            print(f"{now_ts()} OK --> Dados enviados com sucesso")
        else:
            print(f"{now_ts()} ERRO --> Falha ao enviar dados")
        time.sleep(SEND_INTERVAL_SEC)
