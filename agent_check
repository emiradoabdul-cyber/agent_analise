import os
import re
import json
import time
import socket
import platform
import subprocess
import sys
from typing import List, Dict, Any, Optional
from urllib.parse import urlparse

print("TEST VERSION 5")


def _script_dir() -> str:
    # 1) PyInstaller (rodando como .exe)
    if getattr(sys, "frozen", False):
        return os.path.dirname(sys.executable)

    # 2) Rodando via exec() (pode não existir __file__)
    f = globals().get("__file__")
    if not f:
        return os.getcwd()

    # 3) Rodando como .py normal
    return os.path.dirname(os.path.abspath(f))


try:
    import psutil  # type: ignore
except Exception:
    psutil = None

try:
    import requests  # type: ignore
except Exception:
    requests = None


# ----------------------------
# Config
# ----------------------------
# Server principal (produção)
POST_URL = os.environ.get("IRAMGW_AGENT_CHECK_URL",
                          "http://104.234.30.69:4444/pc-check")

# Localhost (testes) - se estiver online, usa ele primeiro
LOCAL_POST_URL = os.environ.get(
    "IRAMGW_AGENT_LOCAL_URL", "http://127.0.0.1:4444/pc-check")

SEND_INTERVAL_SEC = int(os.environ.get("AGENT_SEND_INTERVAL_SEC", "60"))

# Quantos processos mandar no máximo (default alto). Ajuste se necessário.
MAX_PROCS = int(os.environ.get("AGENT_MAX_PROCS", "500"))

# Timeout curto para checar localhost (não pode travar o agente)
LOCAL_CHECK_TIMEOUT_SEC = float(os.environ.get(
    "AGENT_LOCAL_CHECK_TIMEOUT_SEC", "0.6"))

# Timeout do POST
POST_TIMEOUT_SEC = float(os.environ.get("AGENT_POST_TIMEOUT_SEC", "10"))

# Quando detecta intrusão, agente para de enviar dados até que o servidor libere
POLL_ACTION_INTERVAL_SEC = float(os.environ.get(
    "AGENT_POLL_ACTION_INTERVAL_SEC", "3"))
# When operator clicks 'ignore', suppress re-alerting for this duration (seconds)
IGNORE_DURATION_SEC = int(os.environ.get("AGENT_IGNORE_DURATION_SEC", "300"))

# URL do frontend/UI onde o arquivo command.html e as APIs estão disponíveis.
# Permite configurar onde o agente deve buscar o arquivo de comandos (ex: http://127.0.0.1:3000)
UI_URL = os.environ.get("IRAMGW_AGENT_UI_URL", "http://127.0.0.1:3000")

# Optional fixed token to authenticate agent requests to the server (16-digit recommended)
AGENT_TOKEN = os.environ.get("IRAMGW_AGENT_TOKEN", "").strip()

# caminhos possíveis para lista de processos suspeitos (será carregada se existir)
SUSPICIOUS_LIST_PATHS = [
    os.path.join(_script_dir(), "list.txt"),
    os.path.join(_script_dir(), "modulos", "Agent", "list.txt"),
    os.path.join(_script_dir(), "public", "modulos", "Agent", "list.txt"),
]

# Lista embutida padrão (fallback quando não houver arquivo externo)
SUSPICIOUS_PATTERNS_DEFAULT = [
    # GENÉRICOS
    "main", "main.exe",
    "service", "service.exe",
    "client", "client.exe",
    "server", "server.exe",
    "update", "update.exe",
    "updater", "updater.exe",
    "install", "install.exe",
    "setup", "setup.exe",
    "patch", "patch.exe",
    "loader", "loader.exe",
    "run", "run.exe",
    "task", "task.exe",
    "app", "app.exe",
    "agent", "agent.exe",
    "helper", "helper.exe",
    "worker", "worker.exe",
    "host", "host.exe",
    "runtime", "runtime.exe",
    # PARECE WINDOWS
    "svchosts", "svchosts.exe",
    "explore", "explore.exe",
    "winlogin", "winlogin.exe",
    "lsasss", "lsasss.exe",
    "csrsss", "csrsss.exe",
    "taskmngr", "taskmngr.exe",
    "spoolsvc", "spoolsvc.exe",
    "serviceshost", "serviceshost.exe",
    "chromeupdate", "chromeupdate.exe",
    # LOLBINS
    "pwsh", "pwsh.exe",
    "cscript", "cscript.exe",
    "mshta", "mshta.exe",
    "rundll32", "rundll32.exe",
    "regsvr32", "regsvr32.exe",
    "schtasks", "schtasks.exe",
    "wmic", "wmic.exe",
    "bitsadmin", "bitsadmin.exe",
    "certutil", "certutil.exe",
    "net", "net.exe",
    "netsh", "netsh.exe",
    "sc", "sc.exe",
    # CONTROLE REMOTO
    "anydesk", "anydesk.exe",
    "teamviewer", "teamviewer.exe",
    "screenconnect", "screenconnect.exe",
    "splashtop", "splashtop.exe",
    "vnc", "vnc.exe",
    "tightvnc", "tightvnc.exe",
    "ultravnc", "ultravnc.exe",
    # FERRAMENTAS OFENSIVAS
    "mimikatz", "mimikatz.exe",
    "psexec", "psexec.exe",
    "procdump", "procdump.exe",
    "beacon", "beacon.exe",
    "cobaltstrike", "cobaltstrike.exe",
    "meterpreter", "meterpreter.exe",
    "empire", "empire.exe",
    "bloodhound", "bloodhound.exe",
    "netcat", "netcat.exe",
    "nc", "nc.exe",
    # KEYLOGGER / SPYWARE
    "keylogger", "keylogger.exe",
    "hook", "hook.exe",
    "capture", "capture.exe",
    "screen", "screen.exe",
    "spy", "spy.exe",
    "stealer", "stealer.exe",
    "grabber", "grabber.exe",
    "logger", "logger.exe",
    "monitor", "monitor.exe",
    "record", "record.exe",
    # MINERADORES
    "xmrig", "xmrig.exe",
    "miner", "miner.exe",
    "minerd", "minerd.exe",
    "cryptonight", "cryptonight.exe",
    "cpuhelper", "cpuhelper.exe",
    "gpuworker", "gpuworker.exe",
]


def get_port() -> str:
    cfg_path = os.path.join(_script_dir(), "agent_check_port.txt")
    if os.path.exists(cfg_path):
        with open(cfg_path, "r", encoding="utf-8") as f:
            return f.read().strip()
    port = input("Digite a sua porta: ").strip()
    with open(cfg_path, "w", encoding="utf-8") as f:
        f.write(port)
    return port


def is_apipa(ip: str) -> bool:
    return ip.startswith("169.254.")


def get_default_gateway_ipv4() -> Optional[str]:
    try:
        out = subprocess.check_output(
            ["ipconfig"], text=True, encoding="cp850", errors="ignore")
        m = re.findall(
            r"(?:Gateway padrão|Default Gateway)[^\d]*(\d+\.\d+\.\d+\.\d+)", out)
        if m:
            for gw in m:
                if not is_apipa(gw):
                    return gw
    except Exception:
        pass
    return None


def is_private_candidate(ip: str) -> int:
    if ip.startswith("192.168."):
        return 300
    if ip.startswith("10."):
        return 200
    if ip.startswith("172."):
        try:
            a = int(ip.split(".")[1])
            if 16 <= a <= 31:
                return 150
        except Exception:
            pass
        return 50
    return 0


def get_local_ipv4() -> str:
    if psutil is None:
        return ""

    gw = get_default_gateway_ipv4()
    candidates: List[str] = []
    for _, addrs in psutil.net_if_addrs().items():
        for a in addrs:
            if a.family == socket.AF_INET:
                ip = a.address
                if not ip or ip.startswith("127.") or is_apipa(ip):
                    continue
                candidates.append(ip)

    if not candidates:
        return ""

    if gw:
        gw_base = ".".join(gw.split(".")[:3]) + "."
        same = [ip for ip in candidates if ip.startswith(gw_base)]
        if same:
            same.sort(key=is_private_candidate, reverse=True)
            return same[0]

    candidates.sort(key=is_private_candidate, reverse=True)
    return candidates[0]


def format_uptime(seconds: int) -> str:
    if seconds < 0:
        seconds = 0
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    return f"{hours}h {minutes:02d}m"


def get_uptime_text() -> str:
    if psutil is None:
        return ""
    try:
        boot = int(psutil.boot_time())
        now = int(time.time())
        return format_uptime(now - boot)
    except Exception:
        return ""


def now_ts() -> str:
    try:
        return time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
    except Exception:
        return str(int(time.time()))


def get_os_name() -> str:
    try:
        system = platform.system() or "Windows"
        release = platform.release() or ""
        if system.lower() == "windows":
            return f"Windows {release}".strip()
        return f"{system} {release}".strip()
    except Exception:
        return ""


def _base_name(name: str) -> str:
    n = (name or "").strip().lower()
    if n.endswith(".exe"):
        n = n[:-4]
    return n


def list_processes() -> List[Dict[str, Any]]:
    """
    Retorna lista extensa de processos.
    Prioriza psutil (melhor qualidade). Fallback Windows tenta tasklist.
    """
    procs: List[Dict[str, Any]] = []

    # ----------------------------
    # Caminho ideal (psutil)
    # ----------------------------
    if psutil is not None:
        try:
            attrs = ["pid", "ppid", "name", "exe", "cmdline",
                     "username", "create_time", "memory_info"]
            for p in psutil.process_iter(attrs=attrs):
                info = p.info or {}
                name = (info.get("name") or "").strip()
                if not name:
                    continue

                mem = info.get("memory_info")
                mem_mb = None
                try:
                    if mem and getattr(mem, "rss", None) is not None:
                        mem_mb = float(mem.rss) / (1024 * 1024)
                except Exception:
                    mem_mb = None

                exe = info.get("exe")
                cmdline = info.get("cmdline")
                if isinstance(cmdline, tuple):
                    cmdline = list(cmdline)

                procs.append({
                    "pid": info.get("pid"),
                    "ppid": info.get("ppid"),
                    "name": name,
                    "base_name": _base_name(name),
                    "exe": exe if exe else None,
                    "cmdline": cmdline if cmdline else None,
                    "username": info.get("username") if info.get("username") else None,
                    "mem_mb": mem_mb,
                    "create_time": info.get("create_time") if info.get("create_time") else None,
                })

            # Ordena por memória só pra priorizar; você já vai detectar no front
            procs.sort(key=lambda x: (x.get("mem_mb") or 0), reverse=True)

            if MAX_PROCS > 0 and len(procs) > MAX_PROCS:
                procs = procs[:MAX_PROCS]

            return procs
        except Exception:
            pass

    # ----------------------------
    # Fallback Windows (tasklist)
    # ----------------------------
    try:
        out = subprocess.check_output(
            ["tasklist", "/FO", "CSV", "/NH"], text=True, encoding="cp850", errors="ignore")
        lines = [ln.strip() for ln in out.splitlines() if ln.strip()]
        for ln in lines:
            parts = [p.strip().strip('"') for p in ln.split('","')]
            if len(parts) < 2:
                continue
            name = parts[0].strip()
            pid = None
            try:
                pid = int(parts[1].strip())
            except Exception:
                pid = None

            mem_mb = None
            if len(parts) >= 5:
                mem_str = parts[4].replace(".", "").replace(
                    "K", "").replace("k", "").strip()
                try:
                    mem_kb = int(mem_str)
                    mem_mb = mem_kb / 1024.0
                except Exception:
                    mem_mb = None

            if not name:
                continue

            procs.append({
                "pid": pid,
                "ppid": None,
                "name": name,
                "base_name": _base_name(name),
                "exe": None,
                "cmdline": None,
                "username": None,
                "mem_mb": mem_mb,
                "create_time": None,
            })

        if MAX_PROCS > 0 and len(procs) > MAX_PROCS:
            procs = procs[:MAX_PROCS]
        return procs
    except Exception:
        return []


def _is_url_reachable_http(url: str, timeout_sec: float) -> bool:
    """
    Verifica rápido se a URL está respondendo.
    Usa HEAD com fallback para GET (alguns servidores bloqueiam HEAD).
    """
    if requests is None:
        return False

    try:
        # Se a URL não tiver caminho, evita erro (mas aqui sempre tem /pc-check)
        r = requests.head(url, timeout=timeout_sec, allow_redirects=True)
        if 200 <= r.status_code < 500:
            return True
    except Exception:
        pass

    try:
        r = requests.get(url, timeout=timeout_sec, allow_redirects=True)
        if 200 <= r.status_code < 500:
            return True
    except Exception:
        pass

    return False


def choose_post_url() -> str:
    """
    Preferência:
    1) Se localhost estiver respondendo -> usa LOCAL_POST_URL
    2) Caso contrário -> usa POST_URL (servidor)
    """
    # Só vale tentar localhost se realmente for localhost/127.0.0.1
    try:
        host = (urlparse(LOCAL_POST_URL).hostname or "").lower()
        is_local = host in ("localhost", "127.0.0.1")
    except Exception:
        is_local = False

    if is_local and _is_url_reachable_http(LOCAL_POST_URL, LOCAL_CHECK_TIMEOUT_SEC):
        return LOCAL_POST_URL

    return POST_URL


def load_suspicious_patterns() -> List[str]:
    """Tenta carregar uma lista local de padrões (uma por linha)."""
    patterns: List[str] = []
    for p in SUSPICIOUS_LIST_PATHS:
        try:
            if os.path.exists(p):
                with open(p, "r", encoding="utf-8") as f:
                    for ln in f:
                        ln = ln.strip()
                        if not ln or ln.startswith("#"):
                            continue
                        patterns.append(ln.lower())
                if patterns:
                    return patterns
        except Exception:
            continue

    # fallback: tentar buscar no servidor público (mesmo host base que POST_URL)
    try:
        base = choose_post_url()
        # transforma http://host:port/pc-check -> http://host:port/modulos/Agent/list.txt
        parsed = urlparse(base)
        root = f"{parsed.scheme}://{parsed.hostname}:{parsed.port}"
        url = root + "/modulos/Agent/list.txt"
        if requests is not None:
            r = requests.get(url, timeout=2)
            if r.status_code == 200:
                for ln in r.text.splitlines():
                    ln = ln.strip()
                    if not ln or ln.startswith("#"):
                        continue
                    patterns.append(ln.lower())
    except Exception:
        pass

    if patterns:
        return patterns

    # fallback to embedded default patterns
    return list(SUSPICIOUS_PATTERNS_DEFAULT)


def _normalize_pattern(s: str) -> str:
    s = (s or "").strip().lower()
    if s.endswith('.exe'):
        return s
    return s


def find_suspicious_in_processes(processes: List[Dict[str, Any]], patterns: List[str]) -> List[str]:
    # simple list of matching process names (kept for compatibility)
    details = find_suspicious_details(processes, patterns)
    return [d['name'] for d in details]


def find_suspicious_details(processes: List[Dict[str, Any]], patterns: List[str]) -> List[Dict[str, Any]]:
    """Return list of { name: <proc name>, matches: [pattern, ...] }"""
    results: List[Dict[str, Any]] = []
    if not patterns:
        return results
    pats = set(_normalize_pattern(p) for p in patterns if p)
    for proc in processes:
        name = (proc.get('name') or '').strip()
        if not name:
            continue
        lname = name.lower()
        base = (proc.get('base_name') or lname.replace('.exe', '')).lower()

        # prepare cmdline / exe strings
        cmdline_val = proc.get('cmdline')
        cmdline_str = ''
        try:
            if isinstance(cmdline_val, (list, tuple)):
                cmdline_str = ' '.join(str(x) for x in cmdline_val if x)
            elif cmdline_val:
                cmdline_str = str(cmdline_val)
        except Exception:
            cmdline_str = ''
        cmdline_str = cmdline_str.lower()
        exe_str = (proc.get('exe') or '')
        exe_str = exe_str.lower() if isinstance(exe_str, str) else ''

        # Strict matching: only consider exact base/name matches (or .exe exact)
        matched_patterns: List[str] = []
        for p in pats:
            if not p:
                continue
            # if pattern contains .exe, require full name match or base match without .exe
            if p.endswith('.exe'):
                if lname == p or base == p[:-4]:
                    matched_patterns.append(p)
                continue

            # otherwise require exact base or full name match
            if base == p or lname == p:
                matched_patterns.append(p)

        if matched_patterns:
            results.append({"name": name, "matches": matched_patterns})

    return results


def perform_action(action: str, target: Optional[str]) -> bool:
    """Executa ação no host. Retorna True se executado (não necessariamente com sucesso total)."""
    try:
        system = platform.system().lower()
        if action == 'restart':
            if system == 'windows':
                subprocess.Popen(['shutdown', '/r', '/t', '5'])
            else:
                subprocess.Popen(['shutdown', '-r', 'now'])
            return True
        if action == 'shutdown':
            if system == 'windows':
                subprocess.Popen(['shutdown', '/s', '/t', '5'])
            else:
                subprocess.Popen(['shutdown', '-h', 'now'])
            return True
        if action and action.startswith('remove'):
            # target can be None, a string, or a dict (with pid, exe, name)
            t = target
            # if target is a JSON string, try to parse
            if isinstance(t, str):
                try:
                    import json as _json
                    parsed = _json.loads(t)
                    t = parsed
                except Exception:
                    t = t.strip()

            # helper: kill by pid
            def kill_pid(pid_val: int):
                try:
                    if psutil:
                        try:
                            p = psutil.Process(int(pid_val))
                            p.kill()
                            return True
                        except Exception:
                            return False
                    else:
                        if system == 'windows':
                            try:
                                subprocess.call(
                                    ['taskkill', '/PID', str(int(pid_val)), '/F'])
                                return True
                            except Exception:
                                return False
                        else:
                            try:
                                subprocess.call(
                                    ['kill', '-9', str(int(pid_val))])
                                return True
                            except Exception:
                                return False
                except Exception:
                    return False

            # helper: kill by name substring
            def kill_by_name(name_val: str):
                try:
                    n = (name_val or '').lower()
                    if not n:
                        return False
                    if psutil:
                        ok = False
                        for p in psutil.process_iter(['name', 'exe']):
                            try:
                                nm = (p.info.get('name') or '').lower()
                                exe = (p.info.get('exe') or '') or ''
                                if n in nm or n in exe.lower():
                                    try:
                                        p.kill()
                                        ok = True
                                    except Exception:
                                        pass
                            except Exception:
                                pass
                        return ok
                    else:
                        if system == 'windows':
                            try:
                                subprocess.call(
                                    ['taskkill', '/IM', name_val, '/F'])
                                return True
                            except Exception:
                                return False
                        else:
                            try:
                                subprocess.call(['pkill', '-f', name_val])
                                return True
                            except Exception:
                                return False
                except Exception:
                    return False

            # helper: remove file and fallback to schedule deletion on Windows
            def remove_file(path_val: str):
                try:
                    if not path_val:
                        return False
                    if os.path.exists(path_val):
                        try:
                            os.remove(path_val)
                            return True
                        except Exception:
                            # try schedule delete on reboot (Windows)
                            try:
                                if system == 'windows':
                                    try:
                                        import ctypes
                                        MOVEFILE_DELAY_UNTIL_REBOOT = 0x4
                                        p = ctypes.windll.kernel32.MoveFileExW(
                                            str(path_val), None, MOVEFILE_DELAY_UNTIL_REBOOT)
                                        return bool(p)
                                    except Exception:
                                        return False
                            except Exception:
                                return False
                    return False
                except Exception:
                    return False

            # process target
            if isinstance(t, dict):
                # try pid first
                pid_val = t.get('pid')
                exe_val = t.get('exe') or t.get('path') or t.get('name')
                name_val = t.get('name')
                if pid_val:
                    try:
                        kill_pid(int(pid_val))
                    except Exception:
                        pass
                if exe_val:
                    try:
                        remove_file(exe_val)
                    except Exception:
                        pass
                if not pid_val and name_val:
                    try:
                        kill_by_name(name_val)
                    except Exception:
                        pass
            else:
                # t can be a string name/path
                if isinstance(t, str) and t:
                    # if looks like a path, try remove; otherwise kill by name
                    if os.path.exists(t):
                        try:
                            remove_file(t)
                        except Exception:
                            pass
                    else:
                        try:
                            kill_by_name(t)
                        except Exception:
                            pass
            # then restart
            return perform_action('restart', None)
    except Exception:
        return False
    return False


def post_payload(port: str, payload: dict) -> bool:
    if requests is None:
        print("requests não está instalado. Instale com: pip install requests")
        return False

    chosen_url = choose_post_url()
    try:
        url = f"{chosen_url}?port={port}"
        r = requests.post(
            url,
            data=json.dumps(payload),
            headers={"Content-Type": "application/json"},
            timeout=POST_TIMEOUT_SEC
        )
        if r.status_code == 200:
            return True
        print(f"Falha HTTP {r.status_code}: {r.text[:200]}")
        return False
    except Exception as e:
        print(f"Erro enviando dados: {e}")
        return False


def poll_action_for_host(port: str, hostname: str) -> Optional[Dict[str, Any]]:
    """Consulta /pc-action e retorna dict { action, target } quando disponível, senão None."""
    try:
        chosen = choose_post_url()
        parsed = urlparse(chosen)
        root = f"{parsed.scheme}://{parsed.hostname}:{parsed.port}"
        action_url = f"{root}/pc-action?port={port}&hostname={hostname}"
        if requests:
            r = requests.get(action_url, timeout=POST_TIMEOUT_SEC)
            if r.status_code == 200:
                try:
                    j = r.json()
                    if isinstance(j, dict) and j.get('ok') and j.get('allow'):
                        return {'action': j.get('action'), 'target': j.get('target')}
                except Exception:
                    return None
    except Exception:
        return None
    return None


def _kill_pid(pid_val: int) -> bool:
    try:
        system = platform.system().lower()
        if psutil:
            try:
                p = psutil.Process(int(pid_val))
                p.kill()
                return True
            except Exception:
                return False
        else:
            if system == 'windows':
                try:
                    subprocess.call(
                        ['taskkill', '/PID', str(int(pid_val)), '/F'])
                    return True
                except Exception:
                    return False
            else:
                try:
                    subprocess.call(['kill', '-9', str(int(pid_val))])
                    return True
                except Exception:
                    return False
    except Exception:
        return False


def _kill_by_name(name_val: str) -> bool:
    try:
        n = (name_val or '').lower()
        if not n:
            return False
        if psutil:
            ok = False
            for p in psutil.process_iter(['name', 'exe']):
                try:
                    nm = (p.info.get('name') or '').lower()
                    exe = (p.info.get('exe') or '') or ''
                    if n in nm or n in exe.lower():
                        try:
                            p.kill()
                            ok = True
                        except Exception:
                            pass
                except Exception:
                    pass
            return ok
        else:
            system = platform.system().lower()
            if system == 'windows':
                try:
                    subprocess.call(['taskkill', '/IM', name_val, '/F'])
                    return True
                except Exception:
                    return False
            else:
                try:
                    subprocess.call(['pkill', '-f', name_val])
                    return True
                except Exception:
                    return False
    except Exception:
        return False


def _remove_file(path_val: str) -> bool:
    try:
        if not path_val:
            return False
        if os.path.exists(path_val):
            try:
                os.remove(path_val)
                return True
            except Exception:
                # try schedule delete on reboot (Windows)
                try:
                    if platform.system().lower() == 'windows':
                        try:
                            import ctypes
                            MOVEFILE_DELAY_UNTIL_REBOOT = 0x4
                            p = ctypes.windll.kernel32.MoveFileExW(
                                str(path_val), None, MOVEFILE_DELAY_UNTIL_REBOOT)
                            return bool(p)
                        except Exception:
                            return False
                except Exception:
                    return False
        return False
    except Exception:
        return False


def poll_command_html(port: str) -> Optional[str]:
    """Fetch public/command.html and return the command token (e.g. '1','2','3') for this port if present."""
    try:
        candidates = []
        # prefer explicit UI_URL if configured (useful when server runs on port 3000)
        try:
            puc = UI_URL
            parsed_ui = urlparse(puc)
            if parsed_ui.hostname:
                port_ui = parsed_ui.port or (
                    443 if parsed_ui.scheme == 'https' else 80)
                candidates.append(
                    f"{parsed_ui.scheme}://{parsed_ui.hostname}:{port_ui}/command.html")
        except Exception:
            pass

        # fallback to same base used for posting (choose_post_url)
        try:
            chosen = choose_post_url()
            parsed = urlparse(chosen)
            if parsed.hostname:
                port_ch = parsed.port or (
                    443 if parsed.scheme == 'https' else 80)
                candidates.append(
                    f"{parsed.scheme}://{parsed.hostname}:{port_ch}/command.html")
        except Exception:
            pass

        # try each candidate until one returns a matching line
        if requests:
            for url in candidates:
                try:
                    headers = {}
                    if AGENT_TOKEN:
                        headers['X-IRAMGW-TOKEN'] = AGENT_TOKEN
                    r = requests.get(url, headers=headers,
                                     timeout=POST_TIMEOUT_SEC)
                    if r.status_code != 200:
                        continue
                    for ln in r.text.splitlines():
                        ln = ln.strip()
                        if not ln:
                            continue
                        parts = re.split(r"\s+", ln)
                        if len(parts) >= 2 and parts[0] == str(port):
                            return parts[1]
                except Exception:
                    continue
    except Exception:
        return None
    return None


def clear_command_entry(port: str) -> bool:
    """Request server to clear command lines for this port (calls /api/command/clear)."""
    try:
        # try UI_URL first (frontend server where command.html lives)
        tried = []
        if requests:
            try:
                parsed_ui = urlparse(UI_URL)
                port_ui = parsed_ui.port or (
                    443 if parsed_ui.scheme == 'https' else 80)
                url_ui = f"{parsed_ui.scheme}://{parsed_ui.hostname}:{port_ui}/api/command/clear"
                tried.append(url_ui)
                headers = {}
                if AGENT_TOKEN:
                    headers['X-IRAMGW-TOKEN'] = AGENT_TOKEN
                r = requests.post(
                    url_ui, json={"port": str(port)}, headers=headers, timeout=POST_TIMEOUT_SEC)
                if r.status_code == 200:
                    try:
                        return bool(r.json().get('ok'))
                    except Exception:
                        return True
            except Exception:
                pass

        # fallback to the base used for POST payloads
        try:
            chosen = choose_post_url()
            parsed = urlparse(chosen)
            root = f"{parsed.scheme}://{parsed.hostname}:{parsed.port}"
            url = f"{root}/api/command/clear"
            tried.append(url)
            headers = {}
            if AGENT_TOKEN:
                headers['X-IRAMGW-TOKEN'] = AGENT_TOKEN
            r = requests.post(
                url, json={"port": str(port)}, headers=headers, timeout=POST_TIMEOUT_SEC)
            if r.status_code == 200:
                try:
                    return bool(r.json().get('ok'))
                except Exception:
                    return True
        except Exception:
            pass
        return False
    except Exception:
        return False
    return False


def report_activity(port: str, hostname: str, message: str, command: str, success: bool) -> bool:
    """Report a textual activity to the server (tries UI_URL then fallback)."""
    try:
        payload = {
            "port": str(port),
            "hostname": hostname,
            "message": message,
            "command": str(command),
            "success": bool(success)
        }
        # try UI first
        if requests:
            try:
                parsed_ui = urlparse(UI_URL)
                port_ui = parsed_ui.port or (
                    443 if parsed_ui.scheme == 'https' else 80)
                url_ui = f"{parsed_ui.scheme}://{parsed_ui.hostname}:{port_ui}/api/pcs/activity"
                headers = {}
                if AGENT_TOKEN:
                    headers['X-IRAMGW-TOKEN'] = AGENT_TOKEN
                r = requests.post(url_ui, json=payload, headers=headers,
                                  timeout=POST_TIMEOUT_SEC)
                if r.status_code == 200:
                    try:
                        return bool(r.json().get('ok'))
                    except Exception:
                        return True
            except Exception:
                pass

            try:
                chosen = choose_post_url()
                parsed = urlparse(chosen)
                url = f"{parsed.scheme}://{parsed.hostname}:{parsed.port}/api/pcs/activity"
                headers = {}
                if AGENT_TOKEN:
                    headers['X-IRAMGW-TOKEN'] = AGENT_TOKEN
                r = requests.post(url, json=payload,
                                  headers=headers, timeout=POST_TIMEOUT_SEC)
                if r.status_code == 200:
                    try:
                        return bool(r.json().get('ok'))
                    except Exception:
                        return True
            except Exception:
                pass
    except Exception:
        pass
    return False


if __name__ == "__main__":
    port = get_port()
    print(f"Using port: {port}")

    hostname = socket.gethostname() or "DESKTOP"
    ip = get_local_ipv4()
    os_name = get_os_name()

    # carregar padrões locais de processos suspeitos (se houver)
    suspicious_patterns = load_suspicious_patterns()
    if suspicious_patterns:
        print(f"Loaded {len(suspicious_patterns)} suspicious patterns")

    blocked = False
    # persist last detected intrusion processes/details so actions can use them
    last_intrusion_procs_full: List[Dict[str, Any]] = []
    suppressed_until = 0.0  # timestamp until which intrusion alerts are suppressed

    while True:
        uptime = get_uptime_text()
        processes = list_processes()

        # debug: announce comparison and list processes one-per-line
        print(
            f"{now_ts()} Comparando processos antes de enviar... (total: {len(processes)})")
        print(f"{now_ts()} Lista de processos detectados:")
        for p in processes:
            try:
                pname = p.get('name') or p.get('base_name') or ''
            except Exception:
                pname = str(p)
            print(f"{now_ts()} - {pname}")

        # detectar processos intrusos localmente se tivermos padrões
        intrusion_details = find_suspicious_details(
            processes, suspicious_patterns)
        intrusion_procs = [d['name'] for d in intrusion_details]
        # collect full process dicts for the detected intrusion processes
        if intrusion_procs:
            last_intrusion_procs_full = [p for p in processes if (
                p.get('name') or '').strip() in intrusion_procs]
        else:
            last_intrusion_procs_full = []
        # if we are currently suppressed (operator clicked ignore), skip alerting
        if suppressed_until and time.time() < suppressed_until:
            if intrusion_details:
                print(f"{now_ts()} Ignorado localmente até {time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(suppressed_until))} - não envia ALERT")
            # clear intrusion lists so they don't trigger blocking
            intrusion_details = []
            intrusion_procs = []
        if intrusion_details:
            for d in intrusion_details:
                print(
                    f"{now_ts()} PERIGO --> Processo: {d['name']} encontrado... AGUARDANDO AÇÃO NA DASH")
        if intrusion_procs and not blocked:
            # enviar alerta único e entrar em modo bloqueado
            alert_payload = {
                "hostname": hostname,
                "status": "ALERT",
                "ip": ip,
                "os": os_name,
                "uptime": uptime,
                "processes": processes,
                "process_count": len(processes),
                "collected_at": int(time.time()),
                "intrusion": True,
                "intrusion_processes": intrusion_procs,
                "blocked": True,
            }
            ok = post_payload(port, alert_payload)
            print(
                f"{now_ts()} {('ALERT SENT' if ok else 'ALERT ERRO')} - {hostname} {intrusion_procs}")
            blocked = True
            # immediately enter blocked polling
            time.sleep(POLL_ACTION_INTERVAL_SEC)
            continue

        if blocked:
            # não enviamos mais dados, apenas consultamos o servidor de ações
            try:
                # 1) first try the DB-backed /pc-action (existing mechanism)
                try:
                    pa = poll_action_for_host(port, hostname)
                    if pa and isinstance(pa, dict) and pa.get('action'):
                        action = pa.get('action')
                        target = pa.get('target')
                        print('Action allowed by server (pc-action):',
                              action, target)
                        if action and action.startswith('remove') and not target:
                            chosen_targets: List[str] = []
                            for lp in last_intrusion_procs_full:
                                exe = lp.get('exe') or ''
                                name = lp.get('name') or ''
                                if exe:
                                    chosen_targets.append(exe)
                                elif name:
                                    chosen_targets.append(name)
                            for t in chosen_targets:
                                try:
                                    ok = False
                                    try:
                                        if isinstance(t, int) or (isinstance(t, str) and t.isdigit()):
                                            ok = _kill_pid(int(t))
                                        elif os.path.exists(str(t)):
                                            ok = _remove_file(str(t))
                                        else:
                                            ok = _kill_by_name(str(t))
                                    except Exception:
                                        ok = False
                                    try:
                                        msg = f"Arquivo/processo: {t} - {'corrigido' if ok else 'falha ao corrigir'}"
                                        report_activity(
                                            port, hostname, msg, action, ok)
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                            # send an updated check to the dashboard before restarting
                            try:
                                time.sleep(1)
                                updated_procs = list_processes()
                                check_payload = {
                                    "hostname": hostname,
                                    "status": "Online",
                                    "ip": ip,
                                    "os": os_name,
                                    "uptime": get_uptime_text(),
                                    "processes": updated_procs,
                                    "process_count": len(updated_procs),
                                    "collected_at": int(time.time()),
                                }
                                posted = post_payload(port, check_payload)
                                try:
                                    report_activity(
                                        port, hostname, "Check enviado apos correção", action, bool(posted))
                                except Exception:
                                    pass
                            except Exception:
                                pass
                            try:
                                perform_action('restart', None)
                            except Exception:
                                pass
                        else:
                            if action == 'ignore':
                                try:
                                    suppressed_until = time.time() + float(IGNORE_DURATION_SEC)
                                    try:
                                        clear_command_entry(port)
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                except Exception:
                    pass

                # 2) fallback: check public/command.html for "<port> <cmd>" entries
                try:
                    cmd = poll_command_html(port)
                    if cmd:
                        print(
                            f"{now_ts()} Command found in command.html for port {port}: {cmd}")
                        # map commands: 1 -> remove+restart, 2 -> shutdown, 3 -> ignore
                        if cmd == '1':
                            # attempt to remove detected intrusion targets (best-effort)
                            chosen_targets: List[str] = []
                            for lp in last_intrusion_procs_full:
                                exe = lp.get('exe') or ''
                                name = lp.get('name') or ''
                                if exe:
                                    chosen_targets.append(exe)
                                elif name:
                                    chosen_targets.append(name)
                            for t in chosen_targets:
                                try:
                                    ok = False
                                    if isinstance(t, int) or (isinstance(t, str) and t.isdigit()):
                                        ok = _kill_pid(int(t))
                                    elif os.path.exists(str(t)):
                                        ok = _remove_file(str(t))
                                    else:
                                        ok = _kill_by_name(str(t))
                                    try:
                                        msg = f"Arquivo/processo: {t} - {'corrigido' if ok else 'falha ao corrigir'}"
                                        report_activity(
                                            port, hostname, msg, '1', ok)
                                    except Exception:
                                        pass
                                except Exception:
                                    pass
                            try:
                                clear_command_entry(port)
                            except Exception:
                                pass
                            perform_action('restart', None)
                            blocked = False
                            time.sleep(0)
                            continue
                        elif cmd == '2':
                            try:
                                clear_command_entry(port)
                            except Exception:
                                pass
                            perform_action('shutdown', None)
                        elif cmd == '3':
                            try:
                                suppressed_until = time.time() + float(IGNORE_DURATION_SEC)
                                clear_command_entry(port)
                            except Exception:
                                pass
                        blocked = False
                        time.sleep(0)
                        continue
                except Exception:
                    pass
            except Exception:
                pass
            time.sleep(POLL_ACTION_INTERVAL_SEC)
            continue

        # normal payload (quando não bloqueado)
        # Before sending normal payload, poll server for any pending action for this host
        pa = poll_action_for_host(port, hostname)
        if pa and isinstance(pa, dict) and pa.get('action'):
            try:
                action = pa.get('action')
                target = pa.get('target')
                print(f"{now_ts()} Action received pre-send: {action} {target}")
                # try to parse target JSON string
                if isinstance(target, str):
                    try:
                        target = json.loads(target)
                    except Exception:
                        pass
                if action:
                    if action and action.startswith('remove') and not target:
                        # fallback to last intrusion targets
                        chosen_targets: List[str] = []
                        for lp in last_intrusion_procs_full:
                            exe = lp.get('exe') or ''
                            name = lp.get('name') or ''
                            if exe:
                                chosen_targets.append(exe)
                            elif name:
                                chosen_targets.append(name)
                        for t in chosen_targets:
                            try:
                                ok = False
                                try:
                                    if isinstance(t, int) or (isinstance(t, str) and t.isdigit()):
                                        ok = _kill_pid(int(t))
                                    elif os.path.exists(str(t)):
                                        ok = _remove_file(str(t))
                                    else:
                                        ok = _kill_by_name(str(t))
                                except Exception:
                                    ok = False
                                try:
                                    msg = f"Arquivo/processo: {t} - {'corrigido' if ok else 'falha ao corrigir'}"
                                    report_activity(
                                        port, hostname, msg, action, ok)
                                except Exception:
                                    pass
                            except Exception:
                                pass
                        # send updated check before restart
                        try:
                            time.sleep(1)
                            updated_procs = list_processes()
                            check_payload = {
                                "hostname": hostname,
                                "status": "Online",
                                "ip": ip,
                                "os": os_name,
                                "uptime": get_uptime_text(),
                                "processes": updated_procs,
                                "process_count": len(updated_procs),
                                "collected_at": int(time.time()),
                            }
                            posted = post_payload(port, check_payload)
                            try:
                                report_activity(
                                    port, hostname, "Check enviado apos correção", action, bool(posted))
                            except Exception:
                                pass
                        except Exception:
                            pass
                        try:
                            perform_action('restart', None)
                        except Exception:
                            pass
                    else:
                        perform_action(action, target)
                # after performing action, skip sending telemetry this iteration
                time.sleep(POLL_ACTION_INTERVAL_SEC)
                continue
            except Exception:
                pass
        else:
            # if no DB action, also check public/command.html for simple port+cmd entries
            try:
                cmd = poll_command_html(port)
                if cmd:
                    print(
                        f"{now_ts()} Command received pre-send from command.html: {cmd}")
                    if cmd == '1':
                        chosen_targets: List[str] = []
                        for lp in last_intrusion_procs_full:
                            exe = lp.get('exe') or ''
                            name = lp.get('name') or ''
                            if exe:
                                chosen_targets.append(exe)
                            elif name:
                                chosen_targets.append(name)
                        for t in chosen_targets:
                            try:
                                if isinstance(t, int) or (isinstance(t, str) and t.isdigit()):
                                    _kill_pid(int(t))
                                elif os.path.exists(str(t)):
                                    _remove_file(str(t))
                                else:
                                    _kill_by_name(str(t))
                            except Exception:
                                pass
                        try:
                            clear_command_entry(port)
                        except Exception:
                            pass
                        perform_action('restart', None)
                        time.sleep(POLL_ACTION_INTERVAL_SEC)
                        continue
                    elif cmd == '2':
                        try:
                            clear_command_entry(port)
                        except Exception:
                            pass
                        perform_action('shutdown', None)
                        time.sleep(POLL_ACTION_INTERVAL_SEC)
                        continue
                    elif cmd == '3':
                        try:
                            suppressed_until = time.time() + float(IGNORE_DURATION_SEC)
                            clear_command_entry(port)
                        except Exception:
                            pass
                        time.sleep(POLL_ACTION_INTERVAL_SEC)
                        continue
            except Exception:
                pass

        payload = {
            "hostname": hostname,
            "status": "Online",
            "ip": ip,
            "os": os_name,
            "uptime": uptime,
            "processes": processes,
            "process_count": len(processes),
            "collected_at": int(time.time()),
        }

        ok = post_payload(port, payload)
        if ok:
            print(f"{now_ts()} OK --> Dados enviados com sucesso")
        else:
            print(f"{now_ts()} ERRO --> Falha ao enviar dados")
        time.sleep(SEND_INTERVAL_SEC)
