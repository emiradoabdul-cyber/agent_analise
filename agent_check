import os
import re
import json
import time
import socket
import platform
import subprocess
import sys
from typing import List, Dict, Any, Optional
from urllib.parse import urlparse

def _script_dir() -> str:
    # 1) PyInstaller (rodando como .exe)
    if getattr(sys, "frozen", False):
        return os.path.dirname(sys.executable)

    # 2) Rodando via exec() (pode não existir __file__)
    f = globals().get("__file__")
    if not f:
        return os.getcwd()

    # 3) Rodando como .py normal
    return os.path.dirname(os.path.abspath(f))


try:
    import psutil  # type: ignore
except Exception:
    psutil = None

try:
    import requests  # type: ignore
except Exception:
    requests = None


# ----------------------------
# Config
# ----------------------------
# Server principal (produção)
POST_URL = os.environ.get("IRAMGW_AGENT_CHECK_URL", "http://104.234.30.69:4444/pc-check")

# Localhost (testes) - se estiver online, usa ele primeiro
LOCAL_POST_URL = os.environ.get("IRAMGW_AGENT_LOCAL_URL", "http://127.0.0.1:4444/pc-check")

SEND_INTERVAL_SEC = int(os.environ.get("AGENT_SEND_INTERVAL_SEC", "60"))

# Quantos processos mandar no máximo (default alto). Ajuste se necessário.
MAX_PROCS = int(os.environ.get("AGENT_MAX_PROCS", "500"))

# Timeout curto para checar localhost (não pode travar o agente)
LOCAL_CHECK_TIMEOUT_SEC = float(os.environ.get("AGENT_LOCAL_CHECK_TIMEOUT_SEC", "0.6"))

# Timeout do POST
POST_TIMEOUT_SEC = float(os.environ.get("AGENT_POST_TIMEOUT_SEC", "10"))


def get_port() -> str:
    cfg_path = os.path.join(_script_dir(), "agent_check_port.txt")
    if os.path.exists(cfg_path):
        with open(cfg_path, "r", encoding="utf-8") as f:
            return f.read().strip()
    port = input("Digite a sua porta: ").strip()
    with open(cfg_path, "w", encoding="utf-8") as f:
        f.write(port)
    return port


def is_apipa(ip: str) -> bool:
    return ip.startswith("169.254.")


def get_default_gateway_ipv4() -> Optional[str]:
    try:
        out = subprocess.check_output(["ipconfig"], text=True, encoding="cp850", errors="ignore")
        m = re.findall(r"(?:Gateway padrão|Default Gateway)[^\d]*(\d+\.\d+\.\d+\.\d+)", out)
        if m:
            for gw in m:
                if not is_apipa(gw):
                    return gw
    except Exception:
        pass
    return None


def is_private_candidate(ip: str) -> int:
    if ip.startswith("192.168."):
        return 300
    if ip.startswith("10."):
        return 200
    if ip.startswith("172."):
        try:
            a = int(ip.split(".")[1])
            if 16 <= a <= 31:
                return 150
        except Exception:
            pass
        return 50
    return 0


def get_local_ipv4() -> str:
    if psutil is None:
        return ""

    gw = get_default_gateway_ipv4()
    candidates: List[str] = []
    for _, addrs in psutil.net_if_addrs().items():
        for a in addrs:
            if a.family == socket.AF_INET:
                ip = a.address
                if not ip or ip.startswith("127.") or is_apipa(ip):
                    continue
                candidates.append(ip)

    if not candidates:
        return ""

    if gw:
        gw_base = ".".join(gw.split(".")[:3]) + "."
        same = [ip for ip in candidates if ip.startswith(gw_base)]
        if same:
            same.sort(key=is_private_candidate, reverse=True)
            return same[0]

    candidates.sort(key=is_private_candidate, reverse=True)
    return candidates[0]


def format_uptime(seconds: int) -> str:
    if seconds < 0:
        seconds = 0
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    return f"{hours}h {minutes:02d}m"


def get_uptime_text() -> str:
    if psutil is None:
        return ""
    try:
        boot = int(psutil.boot_time())
        now = int(time.time())
        return format_uptime(now - boot)
    except Exception:
        return ""


def get_os_name() -> str:
    try:
        system = platform.system() or "Windows"
        release = platform.release() or ""
        if system.lower() == "windows":
            return f"Windows {release}".strip()
        return f"{system} {release}".strip()
    except Exception:
        return ""


def _base_name(name: str) -> str:
    n = (name or "").strip().lower()
    if n.endswith(".exe"):
        n = n[:-4]
    return n


def list_processes() -> List[Dict[str, Any]]:
    """
    Retorna lista extensa de processos.
    Prioriza psutil (melhor qualidade). Fallback Windows tenta tasklist.
    """
    procs: List[Dict[str, Any]] = []

    # ----------------------------
    # Caminho ideal (psutil)
    # ----------------------------
    if psutil is not None:
        try:
            attrs = ["pid", "ppid", "name", "exe", "cmdline", "username", "create_time", "memory_info"]
            for p in psutil.process_iter(attrs=attrs):
                info = p.info or {}
                name = (info.get("name") or "").strip()
                if not name:
                    continue

                mem = info.get("memory_info")
                mem_mb = None
                try:
                    if mem and getattr(mem, "rss", None) is not None:
                        mem_mb = float(mem.rss) / (1024 * 1024)
                except Exception:
                    mem_mb = None

                exe = info.get("exe")
                cmdline = info.get("cmdline")
                if isinstance(cmdline, tuple):
                    cmdline = list(cmdline)

                procs.append({
                    "pid": info.get("pid"),
                    "ppid": info.get("ppid"),
                    "name": name,
                    "base_name": _base_name(name),
                    "exe": exe if exe else None,
                    "cmdline": cmdline if cmdline else None,
                    "username": info.get("username") if info.get("username") else None,
                    "mem_mb": mem_mb,
                    "create_time": info.get("create_time") if info.get("create_time") else None,
                })

            # Ordena por memória só pra priorizar; você já vai detectar no front
            procs.sort(key=lambda x: (x.get("mem_mb") or 0), reverse=True)

            if MAX_PROCS > 0 and len(procs) > MAX_PROCS:
                procs = procs[:MAX_PROCS]

            return procs
        except Exception:
            pass

    # ----------------------------
    # Fallback Windows (tasklist)
    # ----------------------------
    try:
        out = subprocess.check_output(["tasklist", "/FO", "CSV", "/NH"], text=True, encoding="cp850", errors="ignore")
        lines = [ln.strip() for ln in out.splitlines() if ln.strip()]
        for ln in lines:
            parts = [p.strip().strip('"') for p in ln.split('","')]
            if len(parts) < 2:
                continue
            name = parts[0].strip()
            pid = None
            try:
                pid = int(parts[1].strip())
            except Exception:
                pid = None

            mem_mb = None
            if len(parts) >= 5:
                mem_str = parts[4].replace(".", "").replace("K", "").replace("k", "").strip()
                try:
                    mem_kb = int(mem_str)
                    mem_mb = mem_kb / 1024.0
                except Exception:
                    mem_mb = None

            if not name:
                continue

            procs.append({
                "pid": pid,
                "ppid": None,
                "name": name,
                "base_name": _base_name(name),
                "exe": None,
                "cmdline": None,
                "username": None,
                "mem_mb": mem_mb,
                "create_time": None,
            })

        if MAX_PROCS > 0 and len(procs) > MAX_PROCS:
            procs = procs[:MAX_PROCS]
        return procs
    except Exception:
        return []


def _is_url_reachable_http(url: str, timeout_sec: float) -> bool:
    """
    Verifica rápido se a URL está respondendo.
    Usa HEAD com fallback para GET (alguns servidores bloqueiam HEAD).
    """
    if requests is None:
        return False

    try:
        # Se a URL não tiver caminho, evita erro (mas aqui sempre tem /pc-check)
        r = requests.head(url, timeout=timeout_sec, allow_redirects=True)
        if 200 <= r.status_code < 500:
            return True
    except Exception:
        pass

    try:
        r = requests.get(url, timeout=timeout_sec, allow_redirects=True)
        if 200 <= r.status_code < 500:
            return True
    except Exception:
        pass

    return False


def choose_post_url() -> str:
    """
    Preferência:
    1) Se localhost estiver respondendo -> usa LOCAL_POST_URL
    2) Caso contrário -> usa POST_URL (servidor)
    """
    # Só vale tentar localhost se realmente for localhost/127.0.0.1
    try:
        host = (urlparse(LOCAL_POST_URL).hostname or "").lower()
        is_local = host in ("localhost", "127.0.0.1")
    except Exception:
        is_local = False

    if is_local and _is_url_reachable_http(LOCAL_POST_URL, LOCAL_CHECK_TIMEOUT_SEC):
        return LOCAL_POST_URL

    return POST_URL


def post_payload(port: str, payload: dict) -> bool:
    if requests is None:
        print("requests não está instalado. Instale com: pip install requests")
        return False

    chosen_url = choose_post_url()
    try:
        url = f"{chosen_url}?port={port}"
        r = requests.post(
            url,
            data=json.dumps(payload),
            headers={"Content-Type": "application/json"},
            timeout=POST_TIMEOUT_SEC
        )
        if r.status_code == 200:
            return True
        print(f"Falha HTTP {r.status_code}: {r.text[:200]}")
        return False
    except Exception as e:
        print(f"Erro enviando dados: {e}")
        return False


if __name__ == "__main__":
    port = get_port()
    print(f"Using port: {port}")

    hostname = socket.gethostname() or "DESKTOP"
    ip = get_local_ipv4()
    os_name = get_os_name()

    while True:
        uptime = get_uptime_text()
        processes = list_processes()

        payload = {
            "hostname": hostname,
            "status": "Online",
            "ip": ip,
            "os": os_name,
            "uptime": uptime,
            "processes": processes,
            "process_count": len(processes),
            "collected_at": int(time.time()),
        }

        ok = post_payload(port, payload)
        print(("OK" if ok else "ERRO"), "-", hostname, ip, uptime, f"procs={len(processes)}")
        time.sleep(SEND_INTERVAL_SEC)
